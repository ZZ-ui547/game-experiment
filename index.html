<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Stones of the Nile</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    background: #0a0a12;
    color: #e8d5a3;
    font-family: 'Georgia', serif;
    width: 100%;
    height: 100%;
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
  }

  #hud {
    display: flex;
    gap: 16px;
    font-size: 0.85rem;
    padding: 4px 12px;
    flex-wrap: wrap;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 5;
    flex-shrink: 0;
  }
  #hud span { text-shadow: 0 0 6px #c4943a; }

  #game-container {
    position: relative;
    flex: 1;
    overflow: hidden;
    touch-action: none;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: 100%;
    height: 100%;
  }

  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 5, 0, 0.88);
    z-index: 10;
    padding: 16px;
  }
  #overlay.hidden { display: none; }

  #overlay h2 {
    font-size: 1.6rem;
    margin-bottom: 8px;
    text-shadow: 0 0 12px #c4943a;
    text-align: center;
  }
  #overlay p {
    font-size: 0.95rem;
    margin-bottom: 16px;
    text-align: center;
    line-height: 1.5;
    max-width: 320px;
  }

  #overlay button {
    padding: 14px 40px;
    font-size: 1.1rem;
    font-family: 'Georgia', serif;
    background: #c4943a;
    color: #1a0a00;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    letter-spacing: 1px;
    -webkit-tap-highlight-color: transparent;
  }
  #overlay button:hover { background: #e0b050; }

  #controls-hint {
    position: absolute;
    bottom: 8px;
    left: 0;
    right: 0;
    font-size: 0.7rem;
    opacity: 0.4;
    text-align: center;
    z-index: 2;
    pointer-events: none;
  }

  #celebration {
    position: absolute;
    inset: 0;
    z-index: 9;
  }
  #celebration.hidden { display: none; }
</style>
</head>
<body>

<div id="hud">
  <span>Lives: <b id="hud-lives">5</b></span>
  <span>Stones: <b id="hud-stones">10</b></span>
  <span>Pyramid: <b id="hud-pyramid">0</b>/30</span>
  <span>Distance: <b id="hud-dist">0</b>m</span>
  <span>Speed: <b id="hud-speed">1</b></span>
  <span>Danger: <b id="hud-danger">1</b></span>
</div>

<div id="game-container">
  <canvas id="game"></canvas>

  <div id="overlay">
    <h2 id="overlay-title">Stones of the Nile</h2>
    <p id="overlay-text">
      Sail your boat down the Nile and deliver stones to build the Great Pyramid!<br><br>
      Avoid rocks, hippos and crocodiles.<br>
      Jump over obstacles to clear them!<br>
      Collect bonus stones along the way.<br><br>
      Tap a lane or swipe to steer. Swipe up to jump.
    </p>
    <button id="overlay-btn">Set Sail!</button>
  </div>

  <canvas id="celebration" class="hidden"></canvas>
  <div id="controls-hint"></div>
</div>

<script>
// ─── Config ───────────────────────────────────────────────────
const COLS          = 3;
const SCROLL_SPEED  = 1.2;
const BOOST_MULT    = 2.5;
const STONES_START  = 10;
const LIVES_START   = 5;
const PYRAMID_GOAL  = 30;
const DELIVERY_INTERVAL = 500;

// Difficulty scaling (ramps with distance)
const BASE_OBSTACLE_FREQ = 0.45;   // starting obstacle-per-row chance
const MAX_OBSTACLE_FREQ  = 0.68;   // max obstacle-per-row chance
const BASE_BONUS_FREQ    = 0.12;   // starting bonus chance
const MAX_BONUS_FREQ     = 0.35;   // max bonus chance (compensates harder obstacles)
const DOUBLE_OBS_START   = 400;    // distance where 2-obstacle rows can begin
const MAX_DOUBLE_CHANCE  = 0.35;   // max chance of a 2nd obstacle in one row
const DIFF_RAMP_DIST     = 4000;   // distance over which difficulty fully ramps
const BASE_SPEED_MULT    = 1.0;
const MAX_SPEED_MULT     = 2.0;
const SPEED_RAMP_DIST    = 4000;
const JUMP_DURATION      = 32;    // frames airborne
const JUMP_COOLDOWN      = 40;    // frames before next jump

// ─── Responsive Canvas Setup ─────────────────────────────────
const canvas    = document.getElementById('game');
const ctx       = canvas.getContext('2d');
const container = document.getElementById('game-container');

let CELL, ROWS, CANVAS_W, CANVAS_H;

function resizeCanvas() {
  const contW = container.clientWidth;
  const contH = container.clientHeight;

  // 3 lanes filling the width; cell size derived from screen
  CELL = Math.floor(contW / COLS);
  ROWS = Math.max(8, Math.floor(contH / CELL) + 2);

  CANVAS_W = COLS * CELL;
  CANVAS_H = ROWS * CELL;

  canvas.width  = CANVAS_W;
  canvas.height = CANVAS_H;

  if (state) {
    state.boatScreenY = CANVAS_H - CELL * 2;
  }
}

// ─── Controls Hint ────────────────────────────────────────────
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
document.getElementById('controls-hint').textContent =
  isTouchDevice
    ? 'Tap a lane to steer \u2022 Swipe up to jump'
    : 'Arrow keys / A-D to steer \u2022 Space to jump';

// ─── Difficulty helpers ───────────────────────────────────────
function currentSpeedMult() {
  const t = Math.min(1, state.distance / SPEED_RAMP_DIST);
  return BASE_SPEED_MULT + (MAX_SPEED_MULT - BASE_SPEED_MULT) * t;
}

function difficultyT() {
  const t = Math.min(1, state.distance / DIFF_RAMP_DIST);
  return 1 - (1 - t) * (1 - t);  // ease-out: ramps faster early, flattens late
}

function currentObstacleFreq() {
  return BASE_OBSTACLE_FREQ + (MAX_OBSTACLE_FREQ - BASE_OBSTACLE_FREQ) * difficultyT();
}

function currentBonusFreq() {
  return BASE_BONUS_FREQ + (MAX_BONUS_FREQ - BASE_BONUS_FREQ) * difficultyT();
}

function currentDoubleChance() {
  if (state.distance < DOUBLE_OBS_START) return 0;
  const t = Math.min(1, (state.distance - DOUBLE_OBS_START) / (DIFF_RAMP_DIST - DOUBLE_OBS_START));
  const tEased = 1 - (1 - t) * (1 - t);  // ease-out to match obstacle ramp
  return MAX_DOUBLE_CHANCE * tEased;
}

// ─── State ────────────────────────────────────────────────────
let state;

function resetGame() {
  state = {
    running: false,
    gameOver: false,
    won: false,
    speed: SCROLL_SPEED,
    boatLane: 1,
    boatScreenY: CANVAS_H - CELL * 2,
    stones: STONES_START,
    lives: LIVES_START,
    pyramidStones: 0,
    distance: 0,
    distAccum: 0,
    nextDeliveryAt: DELIVERY_INTERVAL,
    rows: [],
    invincibleTimer: 0,
    flash: 0,
    particles: [],
    frameCount: 0,
    touchLane: null,
    lastOpenLanes: [0, 1, 2],
    jumpTimer: 0,
    jumpCooldown: 0,
  };
  // Pre-fill rows with empty water
  for (let i = 0; i < ROWS + 4; i++) {
    state.rows.push({ y: -CELL * 2 + i * CELL, cells: emptyRow() });
  }
}

function emptyRow() {
  const cells = [];
  for (let c = 0; c < COLS; c++) cells.push(null);
  return cells;
}

// ─── Row Generation ───────────────────────────────────────────

function makeObstacleRow() {
  const cells = [null, null, null];
  const types = ['rock', 'hippo', 'croc'];

  // Build the set of lanes reachable from previous row's open lanes
  // (same lane or ±1 — the boat can move one lane per row)
  const reachable = new Set();
  for (const lane of state.lastOpenLanes) {
    if (lane > 0)        reachable.add(lane - 1);
    reachable.add(lane);
    if (lane < COLS - 1) reachable.add(lane + 1);
  }

  // Place first obstacle based on current difficulty
  if (Math.random() < currentObstacleFreq()) {
    const lane = Math.floor(Math.random() * COLS);
    cells[lane] = types[Math.floor(Math.random() * types.length)];

    // Potentially place a second obstacle, but ensure at least one
    // reachable lane stays free so the boat always has a valid path
    if (Math.random() < currentDoubleChance()) {
      const free = [];
      for (let c = 0; c < COLS; c++) { if (!cells[c]) free.push(c); }
      // Filter candidates: blocking this lane must still leave a
      // reachable free lane
      const candidates = free.filter(c => {
        // If we block lane c, check remaining free lanes are reachable
        for (const f of free) {
          if (f !== c && reachable.has(f)) return true;
        }
        return false;
      });
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        cells[pick] = types[Math.floor(Math.random() * types.length)];
      }
    }

    // Safety net: if the first obstacle itself blocks all reachable lanes,
    // remove it (can happen when reachable set is small)
    const openAfter = [];
    for (let c = 0; c < COLS; c++) {
      if (!cells[c] && reachable.has(c)) openAfter.push(c);
    }
    if (openAfter.length === 0) {
      cells[Math.floor(Math.random() * COLS)] = null; // clear an obstacle
      // Pick a reachable lane to guarantee safe
      for (let c = 0; c < COLS; c++) {
        if (reachable.has(c)) { cells[c] = null; break; }
      }
    }
  }

  // Optionally place a bonus stone in one of the empty lanes
  const emptyLanes = [];
  for (let c = 0; c < COLS; c++) {
    if (!cells[c]) emptyLanes.push(c);
  }
  if (emptyLanes.length > 0 && Math.random() < currentBonusFreq()) {
    const pick = emptyLanes[Math.floor(Math.random() * emptyLanes.length)];
    cells[pick] = 'stone';
  }

  // Update lastOpenLanes: lanes free of lethal obstacles AND reachable
  state.lastOpenLanes = [];
  for (let c = 0; c < COLS; c++) {
    if (!(cells[c] && cells[c] !== 'stone') && reachable.has(c)) {
      state.lastOpenLanes.push(c);
    }
  }
  // Fallback: if somehow empty, treat all non-obstacle lanes as open
  if (state.lastOpenLanes.length === 0) {
    for (let c = 0; c < COLS; c++) {
      if (!(cells[c] && cells[c] !== 'stone')) state.lastOpenLanes.push(c);
    }
  }

  return cells;
}

function makeDeliveryRow() {
  const cells = [];
  for (let c = 0; c < COLS; c++) cells.push('delivery');
  return cells;
}

function spawnRow() {
  const topY = state.rows.length > 0 ? state.rows[0].y : 0;
  const y = topY - CELL;

  let cells;
  if (state.distance >= state.nextDeliveryAt) {
    cells = makeDeliveryRow();
    state.nextDeliveryAt = state.distance + DELIVERY_INTERVAL;
    // Delivery rows are fully passable — reset reachability to all lanes
    state.lastOpenLanes = [0, 1, 2];
  } else {
    cells = makeObstacleRow();
  }
  state.rows.unshift({ y, cells });
}

// ─── Pixel Art Drawing ───────────────────────────────────────

// Pixel helper: draw a small grid of colored pixels scaled to cell
function drawPixels(pixels, ox, oy, pxSize) {
  for (let r = 0; r < pixels.length; r++) {
    for (let c = 0; c < pixels[r].length; c++) {
      const col = pixels[r][c];
      if (!col) continue;
      ctx.fillStyle = col;
      ctx.fillRect(ox + c * pxSize, oy + r * pxSize, pxSize, pxSize);
    }
  }
}

// Color palette
const C = {
  brown:  '#8B5E3C',
  dkBrn:  '#5a3a1e',
  hull:   '#a67c52',
  sail:   '#f5f0e0',
  gold:   '#c4943a',
  stone:  '#888888',
  dkStone:'#666666',
  red:    '#cc3333',
  hippo:  '#7a6688',
  croc:   '#4a8844',
  water1: '#1b5d7e',
  water2: '#164d6a',
  blue:   '#66ccff',
  sand:   '#c4a35a',
  gem:    '#44aaff',
  gemHi:  '#88ccff',
  white:  '#ffffff',
  dkGold: '#a07020',
  delBg:  'rgba(196, 148, 58, 0.25)',
};

// Rock sprite (8x8)
const ROCK_SPRITE = [
  [0,0,0,'#999',C.stone,0,0,0],
  [0,0,'#999',C.stone,C.stone,C.dkStone,0,0],
  [0,'#aaa',C.stone,C.stone,C.dkStone,C.dkStone,'#555',0],
  ['#999',C.stone,C.dkStone,C.stone,C.stone,C.dkStone,C.dkStone,0],
  ['#aaa',C.stone,C.stone,C.dkStone,C.dkStone,C.stone,'#555',0],
  [0,C.stone,C.dkStone,C.dkStone,C.stone,C.dkStone,0,0],
  [0,0,C.dkStone,C.stone,C.dkStone,'#555',0,0],
  [0,0,0,C.dkStone,'#555',0,0,0],
];

// Hippo sprite (8x8)
const HIPPO_SPRITE = [
  [0,0,C.hippo,C.hippo,C.hippo,C.hippo,0,0],
  [0,C.hippo,'#9988aa',C.hippo,C.hippo,'#9988aa',C.hippo,0],
  [0,C.hippo,C.white,C.hippo,C.hippo,C.white,C.hippo,0],
  [C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo],
  [C.hippo,'#8877aa',C.hippo,C.hippo,C.hippo,C.hippo,'#8877aa',C.hippo],
  [0,C.hippo,C.hippo,'#9988aa','#9988aa',C.hippo,C.hippo,0],
  [0,0,C.hippo,C.hippo,C.hippo,C.hippo,0,0],
  [0,0,'#665577',0,0,'#665577',0,0],
];

// Croc sprite (8x8)
const CROC_SPRITE = [
  [0,0,0,C.croc,C.croc,0,0,0],
  [0,0,C.croc,'#5aa855',C.croc,C.croc,0,0],
  [0,C.croc,C.white,C.croc,C.croc,C.red,C.croc,0],
  [C.croc,C.croc,C.croc,C.croc,C.croc,C.croc,C.croc,C.croc],
  [0,'#3a6634',C.croc,C.croc,C.croc,C.croc,'#3a6634',0],
  [0,0,'#3a6634',C.croc,C.croc,'#3a6634',0,0],
  [0,0,0,'#3a6634','#3a6634',0,0,0],
  [0,0,0,0,0,0,0,0],
];

// Gem/stone sprite (8x8)
const GEM_SPRITE = [
  [0,0,0,C.gemHi,0,0,0,0],
  [0,0,C.gemHi,C.gem,C.gemHi,0,0,0],
  [0,C.blue,C.gem,C.gem,C.gem,C.blue,0,0],
  [C.blue,C.gem,C.gemHi,C.gem,C.gem,C.gem,C.blue,0],
  [0,C.blue,C.gem,C.gem,C.gemHi,C.blue,0,0],
  [0,0,C.blue,C.gem,C.blue,0,0,0],
  [0,0,0,C.blue,0,0,0,0],
  [0,0,0,0,0,0,0,0],
];

// Boat sprite (10x12)
const BOAT_SPRITE = [
  [0,0,0,0,C.dkBrn,0,0,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,0,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,C.sail,0,0],
  [0,0,0,0,C.dkBrn,C.gold,C.sail,C.sail,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,0,0,0,0],
  [0,0,C.hull,C.hull,C.hull,C.hull,C.hull,C.hull,0,0],
  [0,C.hull,C.stone,C.stone,C.hull,C.hull,C.stone,C.hull,C.hull,0],
  [0,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,0],
  [0,0,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,0,0],
  [0,0,0,C.dkBrn,C.dkBrn,C.dkBrn,C.dkBrn,0,0,0],
];

function drawSprite(sprite, cx, cy, scale) {
  const rows = sprite.length;
  const cols = sprite[0].length;
  const ox = cx - (cols * scale) / 2;
  const oy = cy - (rows * scale) / 2;
  drawPixels(sprite, ox, oy, scale);
}

// ─── Water & Background ──────────────────────────────────────

function drawWater() {
  ctx.fillStyle = C.water1;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Pixel-style wave lines
  const waveOff = (state.frameCount * 0.6) % 32;
  ctx.fillStyle = 'rgba(100, 200, 235, 0.08)';
  for (let y = -32 + waveOff; y < CANVAS_H + 32; y += 32) {
    for (let x = 0; x < CANVAS_W; x += 8) {
      const shimmer = Math.sin((x + state.frameCount * 0.4) * 0.08) * 3;
      ctx.fillRect(x, y + shimmer, 6, 2);
    }
  }

  // Sandy banks
  const bankW = 6;
  ctx.fillStyle = C.sand;
  for (let y = 0; y < CANVAS_H; y += 4) {
    const w = bankW + Math.sin(y * 0.1 + state.frameCount * 0.02) * 2;
    ctx.fillRect(0, y, w, 4);
    ctx.fillRect(CANVAS_W - w, y, w, 4);
  }

  // Lane dividers (dotted pixel lines)
  ctx.fillStyle = 'rgba(100, 200, 235, 0.06)';
  for (let c = 1; c < COLS; c++) {
    for (let y = 0; y < CANVAS_H; y += 12) {
      ctx.fillRect(c * CELL - 1, y, 2, 6);
    }
  }
}

function drawLaneHighlight() {
  if (state.touchLane == null) return;
  ctx.fillStyle = 'rgba(196, 148, 58, 0.12)';
  ctx.fillRect(state.touchLane * CELL, 0, CELL, CANVAS_H);
}

// ─── Draw Rows ───────────────────────────────────────────────

function drawRows() {
  const pxScale = Math.floor(CELL / 10); // each sprite pixel = ~4-5 canvas pixels

  for (const row of state.rows) {
    if (row.y < -CELL || row.y > CANVAS_H + CELL) continue;

    for (let c = 0; c < COLS; c++) {
      const cell = row.cells[c];
      if (!cell) continue;

      const cx = c * CELL + CELL / 2;
      const cy = row.y + CELL / 2;

      if (cell === 'rock') {
        drawSprite(ROCK_SPRITE, cx, cy, pxScale);
      } else if (cell === 'hippo') {
        drawSprite(HIPPO_SPRITE, cx, cy, pxScale);
      } else if (cell === 'croc') {
        drawSprite(CROC_SPRITE, cx, cy, pxScale);
      } else if (cell === 'stone') {
        // Pulsing glow
        const pulse = 0.6 + 0.4 * Math.sin(state.frameCount * 0.08 + c);
        ctx.fillStyle = `rgba(100, 200, 255, ${0.12 * pulse})`;
        ctx.fillRect(cx - CELL * 0.3, cy - CELL * 0.3, CELL * 0.6, CELL * 0.6);
        drawSprite(GEM_SPRITE, cx, cy, pxScale);
      } else if (cell === 'delivery') {
        // Delivery zone
        ctx.fillStyle = C.delBg;
        ctx.fillRect(c * CELL, row.y, CELL, CELL);
        // Pyramid icon (simple pixel triangle)
        const triH = CELL * 0.4;
        const triW = CELL * 0.5;
        ctx.fillStyle = C.gold;
        for (let py = 0; py < triH; py += pxScale) {
          const w = triW * (py / triH);
          ctx.fillRect(cx - w / 2, cy - triH / 2 + py, w, pxScale);
        }
        // Label
        ctx.fillStyle = C.gold;
        ctx.font = (pxScale * 2) + 'px Georgia';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('DELIVER', cx, cy + triH * 0.3);
      }
    }
  }
}

// ─── Draw Boat ───────────────────────────────────────────────

function drawBoat() {
  if (state.invincibleTimer > 0 && Math.floor(state.flash) % 2 === 0) return;

  const bx = state.boatLane * CELL + CELL / 2;
  const baseY = state.boatScreenY;
  const pxScale = Math.floor(CELL / 12);

  // Jump lift: sine arc for smooth rise & fall
  let liftY = 0;
  if (state.jumpTimer > 0) {
    const jumpProgress = 1 - state.jumpTimer / JUMP_DURATION;
    liftY = Math.sin(jumpProgress * Math.PI) * CELL * 0.8;

    // Shadow on the water
    const shadowAlpha = 0.15 + 0.1 * (1 - jumpProgress);
    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
    const shadowW = CELL * 0.5 * (1 - liftY / (CELL * 0.8) * 0.3);
    ctx.beginPath();
    ctx.ellipse(bx, baseY + pxScale * 4, shadowW, pxScale * 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  const by = baseY - liftY;
  drawSprite(BOAT_SPRITE, bx, by, pxScale);

  // Show cargo count
  const shown = Math.min(state.stones, 5);
  ctx.fillStyle = C.stone;
  for (let i = 0; i < shown; i++) {
    ctx.fillRect(bx - 8 * pxScale / 2 + i * pxScale * 2, by + 2 * pxScale, pxScale, pxScale);
  }
}

function drawJumpIndicator() {
  const bx = state.boatLane * CELL + CELL / 2;
  const by = state.boatScreenY + CELL * 0.55;
  const barW = CELL * 0.5;
  const barH = 4;

  if (state.jumpTimer > 0) {
    // Airborne — show remaining jump time
    const t = state.jumpTimer / JUMP_DURATION;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx - barW / 2, by, barW, barH);
    ctx.fillStyle = '#ffee66';
    ctx.fillRect(bx - barW / 2, by, barW * t, barH);
  } else if (state.jumpCooldown > 0) {
    // Cooldown — show recharge
    const t = 1 - state.jumpCooldown / JUMP_COOLDOWN;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(bx - barW / 2, by, barW, barH);
    ctx.fillStyle = '#666';
    ctx.fillRect(bx - barW / 2, by, barW * t, barH);
  } else {
    // Ready — subtle glow
    const pulse = 0.4 + 0.3 * Math.sin(state.frameCount * 0.1);
    ctx.fillStyle = `rgba(255, 238, 102, ${pulse})`;
    ctx.fillRect(bx - barW / 2, by, barW, barH);
  }
}

// ─── Particles ────────────────────────────────────────────────

function drawParticles() {
  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    if (p.life <= 0) { state.particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    // Pixelated square particles
    const sz = Math.max(2, Math.floor(p.size * p.life));
    ctx.fillRect(Math.floor(p.x), Math.floor(p.y), sz, sz);
  }
  ctx.globalAlpha = 1;
}

function drawPyramidProgress() {
  const pad = 8;
  const pw = 52;
  const ph = 44;
  const px = CANVAS_W - pw - pad;
  const py = pad;
  const progress = state.pyramidStones / PYRAMID_GOAL;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(px - 4, py - 4, pw + 8, ph + 8);

  // Outline triangle
  ctx.strokeStyle = C.gold;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(px + pw / 2, py + 2);
  ctx.lineTo(px + pw - 4, py + ph - 2);
  ctx.lineTo(px + 4, py + ph - 2);
  ctx.closePath();
  ctx.stroke();

  // Filled progress
  if (progress > 0) {
    const h = (ph - 6) * Math.min(progress, 1);
    const topY = py + ph - 2 - h;
    const halfW = (pw / 2 - 4) * (h / (ph - 6));
    ctx.fillStyle = C.gold;
    ctx.beginPath();
    ctx.moveTo(px + pw / 2 - halfW, py + ph - 2);
    ctx.lineTo(px + pw / 2 + halfW, py + ph - 2);
    ctx.lineTo(px + pw / 2 + halfW * 0.9, topY);
    ctx.lineTo(px + pw / 2 - halfW * 0.9, topY);
    ctx.closePath();
    ctx.fill();
  }
}

// ─── Speed indicator ──────────────────────────────────────────
function drawSpeedBar() {
  const pad = 8;
  const barW = 52;
  const barH = 6;
  const bx = pad;
  const by = pad;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(bx - 2, by - 2, barW + 4, barH + 12);

  ctx.fillStyle = '#aaa';
  ctx.font = '8px Georgia';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('SPEED', bx, by);

  const t = Math.min(1, state.distance / SPEED_RAMP_DIST);
  ctx.fillStyle = '#333';
  ctx.fillRect(bx, by + 10, barW, barH);
  const r = Math.floor(255 * t);
  const g = Math.floor(180 * (1 - t));
  ctx.fillStyle = `rgb(${r},${g},0)`;
  ctx.fillRect(bx, by + 10, barW * t, barH);
}

// ─── Collision ────────────────────────────────────────────────

function checkCollisions() {
  const pxScale = Math.floor(CELL / 12);
  const boatH = BOAT_SPRITE.length * pxScale;
  const boatTop = state.boatScreenY - boatH / 2 + pxScale * 2;
  const boatBot = state.boatScreenY + boatH / 2 - pxScale * 2;

  for (const row of state.rows) {
    const rowTop = row.y;
    const rowBot = row.y + CELL;
    if (rowBot < boatTop || rowTop > boatBot) continue;

    const cell = row.cells[state.boatLane];
    if (!cell) continue;

    if (cell === 'rock' || cell === 'hippo' || cell === 'croc') {
      if (state.jumpTimer > 0) return; // airborne — sail over obstacles
      if (state.invincibleTimer <= 0) {
        state.lives--;
        state.invincibleTimer = 90;
        spawnHitParticles();
        row.cells[state.boatLane] = null;
        if (state.lives <= 0) {
          state.lives = 0;
          state.gameOver = true;
          state.running = false;
          showOverlay('Shipwreck!',
            'Your boat sank in the Nile!\nDistance: ' + state.distance + 'm\nPyramid: ' + state.pyramidStones + '/' + PYRAMID_GOAL,
            'Try Again');
        }
      }
      return;
    }

    if (cell === 'stone') {
      state.stones += 2;
      row.cells[state.boatLane] = null;
      spawnCollectParticles();
    }

    if (cell === 'delivery' && state.stones > 0) {
      const deliver = Math.min(state.stones, 5);
      state.stones -= deliver;
      state.pyramidStones += deliver;
      spawnDeliveryParticles();
      for (let c = 0; c < COLS; c++) row.cells[c] = null;

      if (state.pyramidStones >= PYRAMID_GOAL) {
        state.won = true;
        state.running = false;
        showOverlay('Pyramid Complete!',
          'You delivered ' + PYRAMID_GOAL + ' stones!\nThe Great Pyramid is built!\nDistance: ' + state.distance + 'm',
          'Play Again');
        startCelebration();
      }
    }
  }
}

// ─── Clear jumped obstacles on landing ─────────────────────────

function clearObstaclesUnderBoat() {
  const pxScale = Math.floor(CELL / 12);
  const boatH = BOAT_SPRITE.length * pxScale;
  const boatTop = state.boatScreenY - boatH / 2;
  const boatBot = state.boatScreenY + boatH / 2;

  for (const row of state.rows) {
    const rowTop = row.y;
    const rowBot = row.y + CELL;
    if (rowBot < boatTop || rowTop > boatBot) continue;

    const cell = row.cells[state.boatLane];
    if (cell === 'rock' || cell === 'hippo' || cell === 'croc') {
      row.cells[state.boatLane] = null;
    }
  }
}

// ─── Particles ────────────────────────────────────────────────

function spawnHitParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 12; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      size: 3 + Math.random() * 3,
      life: 1,
      color: '#ff6644',
    });
  }
}

function spawnCollectParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 8; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 3,
      vy: -Math.random() * 3,
      size: 2 + Math.random() * 3,
      life: 1,
      color: '#66ccff',
    });
  }
}

function spawnDeliveryParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 20; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 5,
      vy: -Math.random() * 5,
      size: 2 + Math.random() * 4,
      life: 1,
      color: Math.random() > 0.5 ? '#c4943a' : '#e8d5a3',
    });
  }
}

// ─── Input: Keyboard ──────────────────────────────────────────

const keys = {};
let jumpQueued = false;
document.addEventListener('keydown', e => {
  if ((e.key === ' ' || e.key === 'ArrowUp') && !keys[e.key]) {
    jumpQueued = true;
  }
  keys[e.key] = true;
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '].includes(e.key)) {
    e.preventDefault();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

function tryJump() {
  if (!state.running) return;
  if (state.jumpTimer > 0 || state.jumpCooldown > 0) return;
  state.jumpTimer = JUMP_DURATION;
}

let moveCD = 0;
function handleKeyboard() {
  moveCD = Math.max(0, moveCD - 1);
  if (moveCD === 0) {
    if (keys['ArrowLeft']  || keys['a'] || keys['A']) { moveBoat(-1); moveCD = 8; }
    if (keys['ArrowRight'] || keys['d'] || keys['D']) { moveBoat(1);  moveCD = 8; }
  }
  if (jumpQueued) { jumpQueued = false; tryJump(); }
  state.speed = state.jumpTimer > 0
    ? SCROLL_SPEED * currentSpeedMult() * BOOST_MULT
    : SCROLL_SPEED * currentSpeedMult();
}

function moveBoat(dir) {
  if (!state.running) return;
  state.boatLane = Math.max(0, Math.min(COLS - 1, state.boatLane + dir));
}

// ─── Input: Touch ─────────────────────────────────────────────

let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let touchActive = false;
const SWIPE_THRESHOLD = 30;

function canvasTouchPos(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  const scaleX = CANVAS_W / rect.width;
  const scaleY = CANVAS_H / rect.height;
  return {
    x: (touch.clientX - rect.left) * scaleX,
    y: (touch.clientY - rect.top) * scaleY,
  };
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (!state || !state.running) return;
  const pos = canvasTouchPos(e);
  touchStartX = pos.x;
  touchStartY = pos.y;
  touchStartTime = Date.now();
  touchActive = true;
  state.touchLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
}, { passive: false });

let touchJumpTriggered = false;
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  const pos = canvasTouchPos(e);
  const dy = touchStartY - pos.y;
  if (dy > SWIPE_THRESHOLD && !touchJumpTriggered) {
    touchJumpTriggered = true;
    tryJump();
  }
  state.touchLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  touchActive = false;
  touchJumpTriggered = false;
  state.touchLane = null;

  const pos = canvasTouchPos(e);
  const dx = pos.x - touchStartX;
  const dy = touchStartY - pos.y;
  const elapsed = Date.now() - touchStartTime;

  if (Math.abs(dx) > SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy)) {
    moveBoat(dx > 0 ? 1 : -1);
    return;
  }

  if (elapsed < 300 && Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) {
    state.boatLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
  }
}, { passive: false });

canvas.addEventListener('touchcancel', () => {
  touchActive = false;
  touchJumpTriggered = false;
  if (state) {
    state.touchLane = null;
  }
});

document.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

// ─── Overlay ──────────────────────────────────────────────────

const overlay    = document.getElementById('overlay');
const overlayT   = document.getElementById('overlay-title');
const overlayP   = document.getElementById('overlay-text');
const overlayBtn = document.getElementById('overlay-btn');

function showOverlay(title, text, btn) {
  overlayT.textContent = title;
  overlayP.textContent = text;
  overlayBtn.textContent = btn;
  overlay.classList.remove('hidden');
}

overlayBtn.addEventListener('click', () => {
  overlay.classList.add('hidden');
  stopCelebration();
  resizeCanvas();
  resetGame();
  state.running = true;
});

// ─── Victory Celebration ─────────────────────────────────────

const celebCanvas = document.getElementById('celebration');
const celebCtx    = celebCanvas.getContext('2d');
let celebActive   = false;
let celebFrame    = 0;
let celebFW       = [];   // firework rockets
let celebSP       = [];   // explosion sparks

function resizeCelebCanvas() {
  celebCanvas.width  = container.clientWidth;
  celebCanvas.height = container.clientHeight;
}

function startCelebration() {
  celebActive = true;
  celebFrame  = 0;
  celebFW     = [];
  celebSP     = [];
  celebCanvas.classList.remove('hidden');
  resizeCelebCanvas();
  overlay.style.background = 'rgba(10, 5, 0, 0.50)';
  playVictoryJingle();
  celebLoop();
}

function stopCelebration() {
  celebActive = false;
  celebCanvas.classList.add('hidden');
  overlay.style.background = '';
}

function celebLoop() {
  if (!celebActive) return;
  celebFrame++;

  const w = celebCanvas.width;
  const h = celebCanvas.height;
  celebCtx.clearRect(0, 0, w, h);

  drawCelebPyramid(w, h);

  // Spawn firework rockets
  if (celebFrame % 18 === 0 || (celebFrame < 50 && celebFrame % 7 === 0)) {
    const colors = ['#ff4444','#44ff44','#ffdd44','#44aaff','#ff44ff','#ffaa22','#c4943a'];
    celebFW.push({
      x: w * 0.1 + Math.random() * w * 0.8,
      y: h,
      vy: -(3.5 + Math.random() * 3),
      fuse: 28 + Math.random() * 22,
      color: colors[Math.floor(Math.random() * colors.length)],
    });
  }

  // Update rockets
  for (let i = celebFW.length - 1; i >= 0; i--) {
    const fw = celebFW[i];
    fw.y += fw.vy;
    fw.fuse--;
    celebCtx.fillStyle = fw.color;
    celebCtx.fillRect(fw.x - 1, fw.y, 3, 6);
    if (fw.fuse <= 0) {
      for (let s = 0; s < 32; s++) {
        const a = Math.random() * Math.PI * 2;
        const spd = 1 + Math.random() * 3;
        celebSP.push({
          x: fw.x, y: fw.y,
          vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
          life: 1, color: fw.color,
          size: 2 + Math.random() * 2,
        });
      }
      celebFW.splice(i, 1);
    }
  }

  // Update sparks
  for (let i = celebSP.length - 1; i >= 0; i--) {
    const s = celebSP[i];
    s.x += s.vx; s.y += s.vy;
    s.vy += 0.04;
    s.life -= 0.014;
    if (s.life <= 0) { celebSP.splice(i, 1); continue; }
    celebCtx.globalAlpha = s.life;
    celebCtx.fillStyle = s.color;
    const sz = Math.max(1, s.size * s.life);
    celebCtx.fillRect(s.x, s.y, sz, sz);
  }
  celebCtx.globalAlpha = 1;

  requestAnimationFrame(celebLoop);
}

function drawCelebPyramid(w, h) {
  const cx = w / 2;
  const baseY = h * 0.82;
  const topY  = h * 0.18;
  const baseHalf = w * 0.32;

  // Radial glow
  const glow = celebCtx.createRadialGradient(cx, (topY + baseY) / 2, 10,
    cx, (topY + baseY) / 2, baseHalf * 1.5);
  glow.addColorStop(0, 'rgba(196, 148, 58, 0.12)');
  glow.addColorStop(1, 'rgba(196, 148, 58, 0)');
  celebCtx.fillStyle = glow;
  celebCtx.fillRect(0, 0, w, h);

  // Pyramid body with gradient
  const grad = celebCtx.createLinearGradient(cx - baseHalf, baseY, cx + baseHalf * 0.3, topY);
  grad.addColorStop(0, '#8a6520');
  grad.addColorStop(0.5, '#c4943a');
  grad.addColorStop(1, '#e0b050');
  celebCtx.fillStyle = grad;
  celebCtx.beginPath();
  celebCtx.moveTo(cx, topY);
  celebCtx.lineTo(cx + baseHalf, baseY);
  celebCtx.lineTo(cx - baseHalf, baseY);
  celebCtx.closePath();
  celebCtx.fill();

  // Stone block lines
  celebCtx.strokeStyle = 'rgba(90, 58, 30, 0.3)';
  celebCtx.lineWidth = 1;
  const rows = 14;
  for (let r = 1; r < rows; r++) {
    const t = r / rows;
    const ly = topY + (baseY - topY) * t;
    const lw = baseHalf * t;
    celebCtx.beginPath();
    celebCtx.moveTo(cx - lw, ly);
    celebCtx.lineTo(cx + lw, ly);
    celebCtx.stroke();
    const blockW = (lw * 2) / (3 + Math.floor(t * 6));
    const off = (r % 2) * blockW * 0.5;
    const prevY = topY + (baseY - topY) * ((r - 1) / rows);
    for (let bx = cx - lw + off; bx < cx + lw; bx += blockW) {
      celebCtx.beginPath();
      celebCtx.moveTo(bx, ly);
      celebCtx.lineTo(bx, prevY);
      celebCtx.stroke();
    }
  }

  // Shimmering capstone
  const shimmer = 0.5 + 0.5 * Math.sin(celebFrame * 0.06);
  celebCtx.fillStyle = `rgba(255, 238, 100, ${0.35 * shimmer})`;
  celebCtx.beginPath();
  celebCtx.arc(cx, topY, 6 + shimmer * 5, 0, Math.PI * 2);
  celebCtx.fill();
}

function playVictoryJingle() {
  try {
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    const master = ac.createGain();
    master.gain.value = 0.25;
    master.connect(ac.destination);
    const t = ac.currentTime + 0.05;

    function note(freq, start, dur, type, vol) {
      const osc = ac.createOscillator();
      const g   = ac.createGain();
      osc.type = type || 'triangle';
      osc.frequency.value = freq;
      g.gain.setValueAtTime(0, t + start);
      g.gain.linearRampToValueAtTime(vol || 0.3, t + start + 0.03);
      g.gain.exponentialRampToValueAtTime(0.001, t + start + dur);
      osc.connect(g); g.connect(master);
      osc.start(t + start);
      osc.stop(t + start + dur + 0.1);
    }

    // Ascending melody (D major)
    note(293.66, 0.0, 0.25);   // D4
    note(369.99, 0.2, 0.25);   // F#4
    note(440.00, 0.4, 0.25);   // A4
    note(587.33, 0.6, 0.35);   // D5
    note(880.00, 0.9, 0.50);   // A5

    // Bass notes
    note(146.83, 0.0, 0.6, 'sine', 0.2);   // D3
    note(220.00, 0.6, 0.5, 'sine', 0.2);   // A3

    // Sustained D-major chord
    note(293.66, 1.3, 1.8);    // D4
    note(369.99, 1.3, 1.8);    // F#4
    note(440.00, 1.3, 1.8);    // A4
    note(587.33, 1.3, 1.8);    // D5
    note(146.83, 1.3, 2.0, 'sine', 0.2);   // D3 bass
  } catch (e) { /* Web Audio unavailable */ }
}

// ─── HUD ──────────────────────────────────────────────────────

function updateHUD() {
  document.getElementById('hud-lives').textContent   = state.lives;
  document.getElementById('hud-stones').textContent  = state.stones;
  document.getElementById('hud-pyramid').textContent = state.pyramidStones;
  document.getElementById('hud-dist').textContent    = state.distance;
  document.getElementById('hud-speed').textContent   = currentSpeedMult().toFixed(1) + 'x';
  const dangerLvl = Math.floor(1 + difficultyT() * 9);
  document.getElementById('hud-danger').textContent  = dangerLvl + '/10';
}

// ─── Game Loop ────────────────────────────────────────────────

function update() {
  if (!state.running) return;

  state.frameCount++;
  handleKeyboard();

  for (const row of state.rows) {
    row.y += state.speed;
  }

  state.distAccum += state.speed;
  state.distance = Math.floor(state.distAccum / 3);

  // Remove off-screen rows at bottom
  while (state.rows.length > 0 && state.rows[state.rows.length - 1].y > CANVAS_H + CELL) {
    state.rows.pop();
  }

  // Spawn new rows at top
  while (state.rows.length === 0 || state.rows[0].y > -CELL) {
    spawnRow();
  }

  if (state.invincibleTimer > 0) {
    state.invincibleTimer--;
    state.flash += 0.3;
  }

  // Check collisions BEFORE decrementing jump timer so the last
  // airborne frame still has immunity (jumpTimer > 0).
  checkCollisions();

  // Jump timers
  if (state.jumpTimer > 0) {
    state.jumpTimer--;
    if (state.jumpTimer === 0) {
      state.jumpCooldown = JUMP_COOLDOWN;
      // Clear any obstacles still overlapping the boat on landing,
      // since the jump arc doesn't move them fully past the hitbox.
      clearObstaclesUnderBoat();
    }
  } else if (state.jumpCooldown > 0) {
    state.jumpCooldown--;
  }
  updateHUD();
}

function draw() {
  drawWater();
  drawLaneHighlight();
  drawRows();
  drawBoat();
  drawJumpIndicator();
  drawParticles();
  drawPyramidProgress();
  drawSpeedBar();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// ─── Init ─────────────────────────────────────────────────────
resizeCanvas();
resetGame();
loop();

window.addEventListener('resize', () => {
  resizeCanvas();
  if (celebActive) resizeCelebCanvas();
});
</script>
</body>
</html>
