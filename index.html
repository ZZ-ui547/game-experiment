<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Stones of the Nile</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    background: #0a0a12;
    color: #e8d5a3;
    font-family: 'Georgia', serif;
    width: 100%;
    height: 100%;
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
  }

  #hud {
    display: flex;
    gap: 16px;
    font-size: 0.85rem;
    padding: 4px 12px;
    flex-wrap: wrap;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 5;
    flex-shrink: 0;
  }
  #hud span { text-shadow: 0 0 6px #c4943a; }

  #game-container {
    position: relative;
    flex: 1;
    overflow: hidden;
    touch-action: none;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: 100%;
    height: 100%;
  }

  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 5, 0, 0.88);
    z-index: 10;
    padding: 16px;
  }
  #overlay.hidden { display: none; }

  #overlay h2 {
    font-size: 1.6rem;
    margin-bottom: 8px;
    text-shadow: 0 0 12px #c4943a;
    text-align: center;
  }
  #overlay p {
    font-size: 0.95rem;
    margin-bottom: 16px;
    text-align: center;
    line-height: 1.5;
    max-width: 320px;
  }

  #overlay button {
    padding: 14px 40px;
    font-size: 1.1rem;
    font-family: 'Georgia', serif;
    background: #c4943a;
    color: #1a0a00;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    letter-spacing: 1px;
    -webkit-tap-highlight-color: transparent;
  }
  #overlay button:hover { background: #e0b050; }

  #controls-hint {
    position: absolute;
    bottom: 8px;
    left: 0;
    right: 0;
    font-size: 0.7rem;
    opacity: 0.4;
    text-align: center;
    z-index: 2;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="hud">
  <span>Lives: <b id="hud-lives">5</b></span>
  <span>Stones: <b id="hud-stones">10</b></span>
  <span>Pyramid: <b id="hud-pyramid">0</b>/30</span>
  <span>Distance: <b id="hud-dist">0</b>m</span>
  <span>Speed: <b id="hud-speed">1</b></span>
</div>

<div id="game-container">
  <canvas id="game"></canvas>

  <div id="overlay">
    <h2 id="overlay-title">Stones of the Nile</h2>
    <p id="overlay-text">
      Sail your boat down the Nile and deliver stones to build the Great Pyramid!<br><br>
      Avoid rocks, hippos and crocodiles.<br>
      Collect bonus stones along the way.<br><br>
      Tap a lane or swipe to steer.
    </p>
    <button id="overlay-btn">Set Sail!</button>
  </div>

  <div id="controls-hint"></div>
</div>

<script>
// ─── Config ───────────────────────────────────────────────────
const COLS          = 3;
const SCROLL_SPEED  = 1.2;
const BOOST_MULT    = 2.5;
const STONES_START  = 10;
const LIVES_START   = 5;
const PYRAMID_GOAL  = 30;
const DELIVERY_INTERVAL = 500;

// Difficulty scaling (ramps with distance)
const OBSTACLE_FREQ = 0.30;
const BONUS_FREQ    = 0.10;
const BASE_SPEED_MULT  = 1.0;
const MAX_SPEED_MULT   = 2.5;
const SPEED_RAMP_DIST  = 4000;

// ─── Responsive Canvas Setup ─────────────────────────────────
const canvas    = document.getElementById('game');
const ctx       = canvas.getContext('2d');
const container = document.getElementById('game-container');

let CELL, ROWS, CANVAS_W, CANVAS_H;

function resizeCanvas() {
  const contW = container.clientWidth;
  const contH = container.clientHeight;

  // 3 lanes filling the width; cell size derived from screen
  CELL = Math.floor(contW / COLS);
  ROWS = Math.max(8, Math.floor(contH / CELL) + 2);

  CANVAS_W = COLS * CELL;
  CANVAS_H = ROWS * CELL;

  canvas.width  = CANVAS_W;
  canvas.height = CANVAS_H;

  if (state) {
    state.boatScreenY = CANVAS_H - CELL * 2;
  }
}

// ─── Controls Hint ────────────────────────────────────────────
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
document.getElementById('controls-hint').textContent =
  isTouchDevice
    ? 'Tap a lane to steer \u2022 Swipe up to boost'
    : 'Arrow keys / A-D to steer \u2022 Space to boost';

// ─── Difficulty helpers ───────────────────────────────────────
function currentSpeedMult() {
  const t = Math.min(1, state.distance / SPEED_RAMP_DIST);
  return BASE_SPEED_MULT + (MAX_SPEED_MULT - BASE_SPEED_MULT) * t;
}

// ─── State ────────────────────────────────────────────────────
let state;

function resetGame() {
  state = {
    running: false,
    gameOver: false,
    won: false,
    speed: SCROLL_SPEED,
    boatLane: 1,
    boatScreenY: CANVAS_H - CELL * 2,
    stones: STONES_START,
    lives: LIVES_START,
    pyramidStones: 0,
    distance: 0,
    distAccum: 0,
    nextDeliveryAt: DELIVERY_INTERVAL,
    rows: [],
    invincibleTimer: 0,
    flash: 0,
    particles: [],
    frameCount: 0,
    touchLane: null,
    lastOpenLanes: [0, 1, 2],
  };
  // Pre-fill rows with empty water
  for (let i = 0; i < ROWS + 4; i++) {
    state.rows.push({ y: -CELL * 2 + i * CELL, cells: emptyRow() });
  }
}

function emptyRow() {
  const cells = [];
  for (let c = 0; c < COLS; c++) cells.push(null);
  return cells;
}

// ─── Row Generation ───────────────────────────────────────────

function makeObstacleRow() {
  const cells = [null, null, null];
  const types = ['rock', 'hippo', 'croc'];

  // Place at most ONE obstacle per row so at least 2 lanes stay safe.
  // This guarantees the player can always dodge from any lane.
  if (Math.random() < OBSTACLE_FREQ) {
    const lane = Math.floor(Math.random() * COLS);
    cells[lane] = types[Math.floor(Math.random() * types.length)];
  }

  // Optionally place a bonus stone in one of the empty lanes
  const emptyLanes = [];
  for (let c = 0; c < COLS; c++) {
    if (!cells[c]) emptyLanes.push(c);
  }
  if (emptyLanes.length > 0 && Math.random() < BONUS_FREQ) {
    const pick = emptyLanes[Math.floor(Math.random() * emptyLanes.length)];
    cells[pick] = 'stone';
  }

  // Update lastOpenLanes to all safe lanes (with max 1 obstacle, always ≥ 2)
  state.lastOpenLanes = [];
  for (let c = 0; c < COLS; c++) {
    if (!(cells[c] && cells[c] !== 'stone')) state.lastOpenLanes.push(c);
  }

  return cells;
}

function makeDeliveryRow() {
  const cells = [];
  for (let c = 0; c < COLS; c++) cells.push('delivery');
  return cells;
}

function spawnRow() {
  const topY = state.rows.length > 0 ? state.rows[0].y : 0;
  const y = topY - CELL;

  let cells;
  if (state.distance >= state.nextDeliveryAt) {
    cells = makeDeliveryRow();
    state.nextDeliveryAt = state.distance + DELIVERY_INTERVAL;
  } else {
    cells = makeObstacleRow();
  }
  state.rows.unshift({ y, cells });
}

// ─── Pixel Art Drawing ───────────────────────────────────────

// Pixel helper: draw a small grid of colored pixels scaled to cell
function drawPixels(pixels, ox, oy, pxSize) {
  for (let r = 0; r < pixels.length; r++) {
    for (let c = 0; c < pixels[r].length; c++) {
      const col = pixels[r][c];
      if (!col) continue;
      ctx.fillStyle = col;
      ctx.fillRect(ox + c * pxSize, oy + r * pxSize, pxSize, pxSize);
    }
  }
}

// Color palette
const C = {
  brown:  '#8B5E3C',
  dkBrn:  '#5a3a1e',
  hull:   '#a67c52',
  sail:   '#f5f0e0',
  gold:   '#c4943a',
  stone:  '#888888',
  dkStone:'#666666',
  red:    '#cc3333',
  hippo:  '#7a6688',
  croc:   '#4a8844',
  water1: '#1b5d7e',
  water2: '#164d6a',
  blue:   '#66ccff',
  sand:   '#c4a35a',
  gem:    '#44aaff',
  gemHi:  '#88ccff',
  white:  '#ffffff',
  dkGold: '#a07020',
  delBg:  'rgba(196, 148, 58, 0.25)',
};

// Rock sprite (8x8)
const ROCK_SPRITE = [
  [0,0,0,'#999',C.stone,0,0,0],
  [0,0,'#999',C.stone,C.stone,C.dkStone,0,0],
  [0,'#aaa',C.stone,C.stone,C.dkStone,C.dkStone,'#555',0],
  ['#999',C.stone,C.dkStone,C.stone,C.stone,C.dkStone,C.dkStone,0],
  ['#aaa',C.stone,C.stone,C.dkStone,C.dkStone,C.stone,'#555',0],
  [0,C.stone,C.dkStone,C.dkStone,C.stone,C.dkStone,0,0],
  [0,0,C.dkStone,C.stone,C.dkStone,'#555',0,0],
  [0,0,0,C.dkStone,'#555',0,0,0],
];

// Hippo sprite (8x8)
const HIPPO_SPRITE = [
  [0,0,C.hippo,C.hippo,C.hippo,C.hippo,0,0],
  [0,C.hippo,'#9988aa',C.hippo,C.hippo,'#9988aa',C.hippo,0],
  [0,C.hippo,C.white,C.hippo,C.hippo,C.white,C.hippo,0],
  [C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo,C.hippo],
  [C.hippo,'#8877aa',C.hippo,C.hippo,C.hippo,C.hippo,'#8877aa',C.hippo],
  [0,C.hippo,C.hippo,'#9988aa','#9988aa',C.hippo,C.hippo,0],
  [0,0,C.hippo,C.hippo,C.hippo,C.hippo,0,0],
  [0,0,'#665577',0,0,'#665577',0,0],
];

// Croc sprite (8x8)
const CROC_SPRITE = [
  [0,0,0,C.croc,C.croc,0,0,0],
  [0,0,C.croc,'#5aa855',C.croc,C.croc,0,0],
  [0,C.croc,C.white,C.croc,C.croc,C.red,C.croc,0],
  [C.croc,C.croc,C.croc,C.croc,C.croc,C.croc,C.croc,C.croc],
  [0,'#3a6634',C.croc,C.croc,C.croc,C.croc,'#3a6634',0],
  [0,0,'#3a6634',C.croc,C.croc,'#3a6634',0,0],
  [0,0,0,'#3a6634','#3a6634',0,0,0],
  [0,0,0,0,0,0,0,0],
];

// Gem/stone sprite (8x8)
const GEM_SPRITE = [
  [0,0,0,C.gemHi,0,0,0,0],
  [0,0,C.gemHi,C.gem,C.gemHi,0,0,0],
  [0,C.blue,C.gem,C.gem,C.gem,C.blue,0,0],
  [C.blue,C.gem,C.gemHi,C.gem,C.gem,C.gem,C.blue,0],
  [0,C.blue,C.gem,C.gem,C.gemHi,C.blue,0,0],
  [0,0,C.blue,C.gem,C.blue,0,0,0],
  [0,0,0,C.blue,0,0,0,0],
  [0,0,0,0,0,0,0,0],
];

// Boat sprite (10x12)
const BOAT_SPRITE = [
  [0,0,0,0,C.dkBrn,0,0,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,0,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,C.sail,0,0],
  [0,0,0,0,C.dkBrn,C.gold,C.sail,C.sail,0,0],
  [0,0,0,0,C.dkBrn,C.sail,C.sail,0,0,0],
  [0,0,0,0,C.dkBrn,C.sail,0,0,0,0],
  [0,0,C.hull,C.hull,C.hull,C.hull,C.hull,C.hull,0,0],
  [0,C.hull,C.stone,C.stone,C.hull,C.hull,C.stone,C.hull,C.hull,0],
  [0,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,0],
  [0,0,C.brown,C.brown,C.brown,C.brown,C.brown,C.brown,0,0],
  [0,0,0,C.dkBrn,C.dkBrn,C.dkBrn,C.dkBrn,0,0,0],
];

function drawSprite(sprite, cx, cy, scale) {
  const rows = sprite.length;
  const cols = sprite[0].length;
  const ox = cx - (cols * scale) / 2;
  const oy = cy - (rows * scale) / 2;
  drawPixels(sprite, ox, oy, scale);
}

// ─── Water & Background ──────────────────────────────────────

function drawWater() {
  ctx.fillStyle = C.water1;
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Pixel-style wave lines
  const waveOff = (state.frameCount * 0.6) % 32;
  ctx.fillStyle = 'rgba(100, 200, 235, 0.08)';
  for (let y = -32 + waveOff; y < CANVAS_H + 32; y += 32) {
    for (let x = 0; x < CANVAS_W; x += 8) {
      const shimmer = Math.sin((x + state.frameCount * 0.4) * 0.08) * 3;
      ctx.fillRect(x, y + shimmer, 6, 2);
    }
  }

  // Sandy banks
  const bankW = 6;
  ctx.fillStyle = C.sand;
  for (let y = 0; y < CANVAS_H; y += 4) {
    const w = bankW + Math.sin(y * 0.1 + state.frameCount * 0.02) * 2;
    ctx.fillRect(0, y, w, 4);
    ctx.fillRect(CANVAS_W - w, y, w, 4);
  }

  // Lane dividers (dotted pixel lines)
  ctx.fillStyle = 'rgba(100, 200, 235, 0.06)';
  for (let c = 1; c < COLS; c++) {
    for (let y = 0; y < CANVAS_H; y += 12) {
      ctx.fillRect(c * CELL - 1, y, 2, 6);
    }
  }
}

function drawLaneHighlight() {
  if (state.touchLane == null) return;
  ctx.fillStyle = 'rgba(196, 148, 58, 0.12)';
  ctx.fillRect(state.touchLane * CELL, 0, CELL, CANVAS_H);
}

// ─── Draw Rows ───────────────────────────────────────────────

function drawRows() {
  const pxScale = Math.floor(CELL / 10); // each sprite pixel = ~4-5 canvas pixels

  for (const row of state.rows) {
    if (row.y < -CELL || row.y > CANVAS_H + CELL) continue;

    for (let c = 0; c < COLS; c++) {
      const cell = row.cells[c];
      if (!cell) continue;

      const cx = c * CELL + CELL / 2;
      const cy = row.y + CELL / 2;

      if (cell === 'rock') {
        drawSprite(ROCK_SPRITE, cx, cy, pxScale);
      } else if (cell === 'hippo') {
        drawSprite(HIPPO_SPRITE, cx, cy, pxScale);
      } else if (cell === 'croc') {
        drawSprite(CROC_SPRITE, cx, cy, pxScale);
      } else if (cell === 'stone') {
        // Pulsing glow
        const pulse = 0.6 + 0.4 * Math.sin(state.frameCount * 0.08 + c);
        ctx.fillStyle = `rgba(100, 200, 255, ${0.12 * pulse})`;
        ctx.fillRect(cx - CELL * 0.3, cy - CELL * 0.3, CELL * 0.6, CELL * 0.6);
        drawSprite(GEM_SPRITE, cx, cy, pxScale);
      } else if (cell === 'delivery') {
        // Delivery zone
        ctx.fillStyle = C.delBg;
        ctx.fillRect(c * CELL, row.y, CELL, CELL);
        // Pyramid icon (simple pixel triangle)
        const triH = CELL * 0.4;
        const triW = CELL * 0.5;
        ctx.fillStyle = C.gold;
        for (let py = 0; py < triH; py += pxScale) {
          const w = triW * (py / triH);
          ctx.fillRect(cx - w / 2, cy - triH / 2 + py, w, pxScale);
        }
        // Label
        ctx.fillStyle = C.gold;
        ctx.font = (pxScale * 2) + 'px Georgia';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('DELIVER', cx, cy + triH * 0.3);
      }
    }
  }
}

// ─── Draw Boat ───────────────────────────────────────────────

function drawBoat() {
  if (state.invincibleTimer > 0 && Math.floor(state.flash) % 2 === 0) return;

  const bx = state.boatLane * CELL + CELL / 2;
  const by = state.boatScreenY;
  const pxScale = Math.floor(CELL / 12);

  drawSprite(BOAT_SPRITE, bx, by, pxScale);

  // Show cargo count
  const shown = Math.min(state.stones, 5);
  ctx.fillStyle = C.stone;
  for (let i = 0; i < shown; i++) {
    ctx.fillRect(bx - 8 * pxScale / 2 + i * pxScale * 2, by + 2 * pxScale, pxScale, pxScale);
  }
}

// ─── Particles ────────────────────────────────────────────────

function drawParticles() {
  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    if (p.life <= 0) { state.particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    // Pixelated square particles
    const sz = Math.max(2, Math.floor(p.size * p.life));
    ctx.fillRect(Math.floor(p.x), Math.floor(p.y), sz, sz);
  }
  ctx.globalAlpha = 1;
}

function drawPyramidProgress() {
  const pad = 8;
  const pw = 52;
  const ph = 44;
  const px = CANVAS_W - pw - pad;
  const py = pad;
  const progress = state.pyramidStones / PYRAMID_GOAL;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(px - 4, py - 4, pw + 8, ph + 8);

  // Outline triangle
  ctx.strokeStyle = C.gold;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(px + pw / 2, py + 2);
  ctx.lineTo(px + pw - 4, py + ph - 2);
  ctx.lineTo(px + 4, py + ph - 2);
  ctx.closePath();
  ctx.stroke();

  // Filled progress
  if (progress > 0) {
    const h = (ph - 6) * Math.min(progress, 1);
    const topY = py + ph - 2 - h;
    const halfW = (pw / 2 - 4) * (h / (ph - 6));
    ctx.fillStyle = C.gold;
    ctx.beginPath();
    ctx.moveTo(px + pw / 2 - halfW, py + ph - 2);
    ctx.lineTo(px + pw / 2 + halfW, py + ph - 2);
    ctx.lineTo(px + pw / 2 + halfW * 0.9, topY);
    ctx.lineTo(px + pw / 2 - halfW * 0.9, topY);
    ctx.closePath();
    ctx.fill();
  }
}

// ─── Speed indicator ──────────────────────────────────────────
function drawSpeedBar() {
  const pad = 8;
  const barW = 52;
  const barH = 6;
  const bx = pad;
  const by = pad;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(bx - 2, by - 2, barW + 4, barH + 12);

  ctx.fillStyle = '#aaa';
  ctx.font = '8px Georgia';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('SPEED', bx, by);

  const t = Math.min(1, state.distance / SPEED_RAMP_DIST);
  ctx.fillStyle = '#333';
  ctx.fillRect(bx, by + 10, barW, barH);
  const r = Math.floor(255 * t);
  const g = Math.floor(180 * (1 - t));
  ctx.fillStyle = `rgb(${r},${g},0)`;
  ctx.fillRect(bx, by + 10, barW * t, barH);
}

// ─── Collision ────────────────────────────────────────────────

function checkCollisions() {
  const pxScale = Math.floor(CELL / 12);
  const boatH = BOAT_SPRITE.length * pxScale;
  const boatTop = state.boatScreenY - boatH / 2 + pxScale * 2;
  const boatBot = state.boatScreenY + boatH / 2 - pxScale * 2;

  for (const row of state.rows) {
    const rowTop = row.y;
    const rowBot = row.y + CELL;
    if (rowBot < boatTop || rowTop > boatBot) continue;

    const cell = row.cells[state.boatLane];
    if (!cell) continue;

    if (cell === 'rock' || cell === 'hippo' || cell === 'croc') {
      if (state.invincibleTimer <= 0) {
        state.lives--;
        state.invincibleTimer = 90;
        spawnHitParticles();
        row.cells[state.boatLane] = null;
        if (state.lives <= 0) {
          state.lives = 0;
          state.gameOver = true;
          state.running = false;
          showOverlay('Shipwreck!',
            'Your boat sank in the Nile!\nDistance: ' + state.distance + 'm\nPyramid: ' + state.pyramidStones + '/' + PYRAMID_GOAL,
            'Try Again');
        }
      }
      return;
    }

    if (cell === 'stone') {
      state.stones += 2;
      row.cells[state.boatLane] = null;
      spawnCollectParticles();
    }

    if (cell === 'delivery' && state.stones > 0) {
      const deliver = Math.min(state.stones, 5);
      state.stones -= deliver;
      state.pyramidStones += deliver;
      spawnDeliveryParticles();
      for (let c = 0; c < COLS; c++) row.cells[c] = null;

      if (state.pyramidStones >= PYRAMID_GOAL) {
        state.won = true;
        state.running = false;
        showOverlay('Pyramid Complete!',
          'You delivered ' + PYRAMID_GOAL + ' stones!\nThe Great Pyramid is built!\nDistance: ' + state.distance + 'm',
          'Play Again');
      }
    }
  }
}

// ─── Particles ────────────────────────────────────────────────

function spawnHitParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 12; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      size: 3 + Math.random() * 3,
      life: 1,
      color: '#ff6644',
    });
  }
}

function spawnCollectParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 8; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 3,
      vy: -Math.random() * 3,
      size: 2 + Math.random() * 3,
      life: 1,
      color: '#66ccff',
    });
  }
}

function spawnDeliveryParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  for (let i = 0; i < 20; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 5,
      vy: -Math.random() * 5,
      size: 2 + Math.random() * 4,
      life: 1,
      color: Math.random() > 0.5 ? '#c4943a' : '#e8d5a3',
    });
  }
}

// ─── Input: Keyboard ──────────────────────────────────────────

const keys = {};
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '].includes(e.key)) {
    e.preventDefault();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

let moveCD = 0;
function handleKeyboard() {
  moveCD = Math.max(0, moveCD - 1);
  if (moveCD === 0) {
    if (keys['ArrowLeft']  || keys['a'] || keys['A']) { moveBoat(-1); moveCD = 8; }
    if (keys['ArrowRight'] || keys['d'] || keys['D']) { moveBoat(1);  moveCD = 8; }
  }
  state.speed = (keys[' '] || keys['ArrowUp'])
    ? SCROLL_SPEED * currentSpeedMult() * BOOST_MULT
    : SCROLL_SPEED * currentSpeedMult();
}

function moveBoat(dir) {
  if (!state.running) return;
  state.boatLane = Math.max(0, Math.min(COLS - 1, state.boatLane + dir));
}

// ─── Input: Touch ─────────────────────────────────────────────

let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let touchActive = false;
const SWIPE_THRESHOLD = 30;

function canvasTouchPos(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  const scaleX = CANVAS_W / rect.width;
  const scaleY = CANVAS_H / rect.height;
  return {
    x: (touch.clientX - rect.left) * scaleX,
    y: (touch.clientY - rect.top) * scaleY,
  };
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (!state || !state.running) return;
  const pos = canvasTouchPos(e);
  touchStartX = pos.x;
  touchStartY = pos.y;
  touchStartTime = Date.now();
  touchActive = true;
  state.touchLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  const pos = canvasTouchPos(e);
  const dy = touchStartY - pos.y;
  state.speed = dy > SWIPE_THRESHOLD
    ? SCROLL_SPEED * currentSpeedMult() * BOOST_MULT
    : SCROLL_SPEED * currentSpeedMult();
  state.touchLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  touchActive = false;
  state.speed = SCROLL_SPEED * currentSpeedMult();
  state.touchLane = null;

  const pos = canvasTouchPos(e);
  const dx = pos.x - touchStartX;
  const dy = touchStartY - pos.y;
  const elapsed = Date.now() - touchStartTime;

  if (Math.abs(dx) > SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy)) {
    moveBoat(dx > 0 ? 1 : -1);
    return;
  }

  if (elapsed < 300 && Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) {
    state.boatLane = Math.max(0, Math.min(COLS - 1, Math.floor(pos.x / CELL)));
  }
}, { passive: false });

canvas.addEventListener('touchcancel', () => {
  touchActive = false;
  if (state) {
    state.speed = SCROLL_SPEED * currentSpeedMult();
    state.touchLane = null;
  }
});

document.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

// ─── Overlay ──────────────────────────────────────────────────

const overlay    = document.getElementById('overlay');
const overlayT   = document.getElementById('overlay-title');
const overlayP   = document.getElementById('overlay-text');
const overlayBtn = document.getElementById('overlay-btn');

function showOverlay(title, text, btn) {
  overlayT.textContent = title;
  overlayP.textContent = text;
  overlayBtn.textContent = btn;
  overlay.classList.remove('hidden');
}

overlayBtn.addEventListener('click', () => {
  overlay.classList.add('hidden');
  resizeCanvas();
  resetGame();
  state.running = true;
});

// ─── HUD ──────────────────────────────────────────────────────

function updateHUD() {
  document.getElementById('hud-lives').textContent   = state.lives;
  document.getElementById('hud-stones').textContent  = state.stones;
  document.getElementById('hud-pyramid').textContent = state.pyramidStones;
  document.getElementById('hud-dist').textContent    = state.distance;
  document.getElementById('hud-speed').textContent   = currentSpeedMult().toFixed(1) + 'x';
}

// ─── Game Loop ────────────────────────────────────────────────

function update() {
  if (!state.running) return;

  state.frameCount++;
  handleKeyboard();

  for (const row of state.rows) {
    row.y += state.speed;
  }

  state.distAccum += state.speed;
  state.distance = Math.floor(state.distAccum / 3);

  // Remove off-screen rows at bottom
  while (state.rows.length > 0 && state.rows[state.rows.length - 1].y > CANVAS_H + CELL) {
    state.rows.pop();
  }

  // Spawn new rows at top
  while (state.rows.length === 0 || state.rows[0].y > -CELL) {
    spawnRow();
  }

  if (state.invincibleTimer > 0) {
    state.invincibleTimer--;
    state.flash += 0.3;
  }

  checkCollisions();
  updateHUD();
}

function draw() {
  drawWater();
  drawLaneHighlight();
  drawRows();
  drawBoat();
  drawParticles();
  drawPyramidProgress();
  drawSpeedBar();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// ─── Init ─────────────────────────────────────────────────────
resizeCanvas();
resetGame();
loop();

window.addEventListener('resize', () => {
  resizeCanvas();
});
</script>
</body>
</html>
