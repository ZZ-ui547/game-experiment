<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Stones of the Nile</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    background: #1a0a00;
    color: #e8d5a3;
    font-family: 'Georgia', serif;
    height: 100%;
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  h1 {
    font-size: 1.3rem;
    margin: 6px 0 2px;
    letter-spacing: 2px;
    text-shadow: 0 0 10px #c4943a;
  }

  #hud {
    display: flex;
    gap: 16px;
    font-size: 0.85rem;
    margin-bottom: 4px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #hud span { text-shadow: 0 0 6px #c4943a; }

  #game-container {
    position: relative;
    border: 3px solid #c4943a;
    border-radius: 4px;
    overflow: hidden;
    touch-action: none;
    /* width set by JS to fill available space */
  }

  canvas {
    display: block;
    background: #1b4d6e;
    width: 100%;
    height: 100%;
  }

  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 5, 0, 0.85);
    z-index: 10;
    padding: 16px;
  }
  #overlay.hidden { display: none; }

  #overlay h2 {
    font-size: 1.6rem;
    margin-bottom: 8px;
    text-shadow: 0 0 12px #c4943a;
    text-align: center;
  }
  #overlay p {
    font-size: 0.95rem;
    margin-bottom: 16px;
    text-align: center;
    line-height: 1.5;
    max-width: 280px;
  }

  #overlay button {
    padding: 14px 40px;
    font-size: 1.1rem;
    font-family: 'Georgia', serif;
    background: #c4943a;
    color: #1a0a00;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    letter-spacing: 1px;
    -webkit-tap-highlight-color: transparent;
  }
  #overlay button:hover { background: #e0b050; }

  #controls-hint {
    margin-top: 6px;
    font-size: 0.75rem;
    opacity: 0.5;
    text-align: center;
  }
</style>
</head>
<body>

<h1>Stones of the Nile</h1>
<div id="hud">
  <span>Stones: <b id="hud-stones">10</b></span>
  <span>Pyramid: <b id="hud-pyramid">0</b>/30</span>
  <span>Distance: <b id="hud-dist">0</b>m</span>
</div>

<div id="game-container">
  <canvas id="game"></canvas>

  <div id="overlay">
    <h2 id="overlay-title">Stones of the Nile</h2>
    <p id="overlay-text">
      Sail your boat down the Nile and deliver stones to build the Great Pyramid!<br><br>
      Avoid rocks, hippos and crocodiles.<br>
      Collect bonus stones along the way.<br><br>
      Tap a lane or swipe to steer.
    </p>
    <button id="overlay-btn">Set Sail!</button>
  </div>
</div>

<div id="controls-hint"></div>

<script>
// ─── Config ───────────────────────────────────────────────────
const COLS = 3;
const ROWS = 9;

const SCROLL_SPEED   = 1.5;
const BOOST_MULT     = 2.5;
const OBSTACLE_FREQ  = 0.30;
const BONUS_FREQ     = 0.10;
const STONES_START   = 10;
const PYRAMID_GOAL   = 30;
const DELIVERY_INTERVAL = 500;

// ─── Responsive Canvas Setup ─────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let CELL, CANVAS_W, CANVAS_H;

function resizeCanvas() {
  const header = document.querySelector('h1');
  const hud = document.getElementById('hud');
  const hint = document.getElementById('controls-hint');
  const headerH = header.offsetHeight + hud.offsetHeight + hint.offsetHeight + 24;
  const maxH = window.innerHeight - headerH;
  const maxW = window.innerWidth - 16; // 8px padding each side

  // Compute cell size: fill width, but cap so height fits screen
  let cell = Math.floor(maxW / COLS);
  if (cell * ROWS > maxH) {
    cell = Math.floor(maxH / ROWS);
  }
  // Reasonable bounds
  cell = Math.max(48, Math.min(cell, 120));

  CELL = cell;
  CANVAS_W = COLS * CELL;
  CANVAS_H = ROWS * CELL;

  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  container.style.width = CANVAS_W + 'px';
  container.style.height = CANVAS_H + 'px';

  // Update boat position if game is running
  if (state) {
    state.boatScreenY = CANVAS_H - CELL * 1.5;
  }
}

// ─── Controls Hint ────────────────────────────────────────────
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
document.getElementById('controls-hint').textContent =
  isTouchDevice
    ? 'Tap a lane to steer \u2022 Swipe up to boost'
    : 'Arrow keys or A/D to steer \u2022 Space to boost';

// ─── State ────────────────────────────────────────────────────
let state;

function resetGame() {
  state = {
    running: false,
    gameOver: false,
    won: false,
    speed: SCROLL_SPEED,
    boatLane: 1,
    boatScreenY: CANVAS_H - CELL * 1.5,
    stones: STONES_START,
    pyramidStones: 0,
    distance: 0,
    distAccum: 0,
    nextDeliveryAt: DELIVERY_INTERVAL,
    rows: [],
    invincibleTimer: 0,
    flash: 0,
    particles: [],
    frameCount: 0,
  };
  for (let i = 0; i < ROWS + 2; i++) {
    state.rows.push({ y: -CELL + i * CELL, cells: [null, null, null] });
  }
}

// ─── Row Generation ───────────────────────────────────────────

function makeObstacleRow() {
  const cells = [null, null, null];
  for (let c = 0; c < COLS; c++) {
    const r = Math.random();
    if (r < OBSTACLE_FREQ) {
      const types = ['rock', 'hippo', 'croc'];
      cells[c] = types[Math.floor(Math.random() * types.length)];
    } else if (r < OBSTACLE_FREQ + BONUS_FREQ) {
      cells[c] = 'stone';
    }
  }
  const blocked = cells.filter(c => c && c !== 'stone').length;
  if (blocked === COLS) {
    cells[Math.floor(Math.random() * COLS)] = null;
  }
  return cells;
}

function makeDeliveryRow() {
  return ['delivery', 'delivery', 'delivery'];
}

function spawnRow() {
  const topY = state.rows.length > 0 ? state.rows[0].y : 0;
  const y = topY - CELL;

  let cells;
  if (state.distance >= state.nextDeliveryAt) {
    cells = makeDeliveryRow();
    state.nextDeliveryAt = state.distance + DELIVERY_INTERVAL;
  } else {
    cells = makeObstacleRow();
  }
  state.rows.unshift({ y, cells });
}

// ─── Drawing ──────────────────────────────────────────────────

function drawWater() {
  ctx.fillStyle = '#1b5d7e';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  ctx.strokeStyle = 'rgba(100, 200, 235, 0.15)';
  ctx.lineWidth = 2;
  const waveOff = (state.frameCount * 0.8) % 40;
  for (let y = -40 + waveOff; y < CANVAS_H + 40; y += 40) {
    ctx.beginPath();
    for (let x = 0; x <= CANVAS_W; x += 4) {
      const yy = y + Math.sin((x + state.frameCount * 0.6) * 0.05) * 6;
      x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
    }
    ctx.stroke();
  }

  const bankW = Math.max(6, CELL * 0.12);
  const g1 = ctx.createLinearGradient(0, 0, bankW, 0);
  g1.addColorStop(0, '#c4a35a');
  g1.addColorStop(1, 'rgba(196,163,90,0)');
  ctx.fillStyle = g1;
  ctx.fillRect(0, 0, bankW, CANVAS_H);

  const g2 = ctx.createLinearGradient(CANVAS_W - bankW, 0, CANVAS_W, 0);
  g2.addColorStop(0, 'rgba(196,163,90,0)');
  g2.addColorStop(1, '#c4a35a');
  ctx.fillStyle = g2;
  ctx.fillRect(CANVAS_W - bankW, 0, bankW, CANVAS_H);

  ctx.strokeStyle = 'rgba(100, 200, 235, 0.08)';
  ctx.setLineDash([8, 8]);
  for (let c = 1; c < COLS; c++) {
    ctx.beginPath();
    ctx.moveTo(c * CELL, 0);
    ctx.lineTo(c * CELL, CANVAS_H);
    ctx.stroke();
  }
  ctx.setLineDash([]);
}

function drawEmoji(emoji, x, y, size) {
  ctx.font = size + 'px serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(emoji, x, y);
}

function drawRows() {
  const emojiSize = Math.round(CELL * 0.5);
  const smallEmoji = Math.round(CELL * 0.39);
  const labelSize = Math.round(CELL * 0.14);

  for (const row of state.rows) {
    if (row.y < -CELL || row.y > CANVAS_H + CELL) continue;

    for (let c = 0; c < COLS; c++) {
      const cell = row.cells[c];
      if (!cell) continue;

      const cx = c * CELL + CELL / 2;
      const cy = row.y + CELL / 2;

      if (cell === 'rock') {
        drawEmoji('\u{1FAA8}', cx, cy, emojiSize);
      } else if (cell === 'hippo') {
        drawEmoji('\u{1F99B}', cx, cy, emojiSize);
      } else if (cell === 'croc') {
        drawEmoji('\u{1F40A}', cx, cy, emojiSize);
      } else if (cell === 'stone') {
        drawEmoji('\u{1F48E}', cx, cy, smallEmoji);
        ctx.fillStyle = 'rgba(100, 200, 255, 0.15)';
        ctx.beginPath();
        ctx.arc(cx, cy, CELL * 0.28, 0, Math.PI * 2);
        ctx.fill();
      } else if (cell === 'delivery') {
        ctx.fillStyle = 'rgba(196, 148, 58, 0.3)';
        ctx.fillRect(c * CELL, row.y, CELL, CELL);
        drawEmoji('\u{1F3D7}\uFE0F', cx, cy - CELL * 0.08, smallEmoji);
        ctx.fillStyle = '#e8d5a3';
        ctx.font = labelSize + 'px Georgia';
        ctx.textAlign = 'center';
        ctx.fillText('DELIVER', cx, cy + CELL * 0.3);
      }
    }
  }
}

function drawBoat() {
  if (state.invincibleTimer > 0 && Math.floor(state.flash) % 2 === 0) return;

  const bx = state.boatLane * CELL + CELL / 2;
  const by = state.boatScreenY;
  const s = CELL / 72; // scale factor relative to original 72px cell

  // Hull
  ctx.fillStyle = '#8B5E3C';
  ctx.beginPath();
  ctx.moveTo(bx - 22 * s, by + 10 * s);
  ctx.lineTo(bx + 22 * s, by + 10 * s);
  ctx.lineTo(bx + 16 * s, by + 22 * s);
  ctx.lineTo(bx - 16 * s, by + 22 * s);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#5a3a1e';
  ctx.lineWidth = 1.5 * s;
  ctx.stroke();

  // Deck
  ctx.fillStyle = '#a67c52';
  ctx.fillRect(bx - 18 * s, by - 2 * s, 36 * s, 14 * s);

  // Stones cargo
  const shown = Math.min(state.stones, 5);
  for (let i = 0; i < shown; i++) {
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.arc(bx - 12 * s + i * 6 * s, by + 4 * s, 4 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 0.5 * s;
    ctx.stroke();
  }

  // Sail
  ctx.fillStyle = '#f5f0e0';
  ctx.beginPath();
  ctx.moveTo(bx, by - 28 * s);
  ctx.lineTo(bx + 16 * s, by - 4 * s);
  ctx.lineTo(bx, by - 2 * s);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#c4943a';
  ctx.lineWidth = 1 * s;
  ctx.stroke();

  // Mast
  ctx.strokeStyle = '#5a3a1e';
  ctx.lineWidth = 2 * s;
  ctx.beginPath();
  ctx.moveTo(bx, by - 30 * s);
  ctx.lineTo(bx, by + 10 * s);
  ctx.stroke();

  // Eye of Horus
  ctx.fillStyle = '#c4943a';
  ctx.font = Math.round(12 * s) + 'px serif';
  ctx.textAlign = 'center';
  ctx.fillText('\u{13080}', bx + 6 * s, by - 12 * s);
}

function drawParticles() {
  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    if (p.life <= 0) { state.particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawPyramidProgress() {
  const s = CELL / 72;
  const px = CANVAS_W - 40 * s;
  const py = 8 * s;
  const progress = state.pyramidStones / PYRAMID_GOAL;

  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(px - 26 * s, py - 2 * s, 58 * s, 40 * s);

  ctx.strokeStyle = '#c4943a';
  ctx.lineWidth = 1.5 * s;
  ctx.beginPath();
  ctx.moveTo(px, py + 4 * s);
  ctx.lineTo(px + 18 * s, py + 32 * s);
  ctx.lineTo(px - 18 * s, py + 32 * s);
  ctx.closePath();
  ctx.stroke();

  if (progress > 0) {
    ctx.fillStyle = '#c4943a';
    ctx.beginPath();
    const h = 28 * s * Math.min(progress, 1);
    const topY = py + 32 * s - h;
    const halfW = 18 * s * (h / (28 * s));
    ctx.moveTo(px - halfW, py + 32 * s);
    ctx.lineTo(px + halfW, py + 32 * s);
    ctx.lineTo(px + halfW * 0.9, topY);
    ctx.lineTo(px - halfW * 0.9, topY);
    ctx.closePath();
    ctx.fill();
  }
}

// ─── Lane highlight on touch ──────────────────────────────────

function drawLaneHighlight() {
  if (state.touchLane == null) return;
  ctx.fillStyle = 'rgba(196, 148, 58, 0.12)';
  ctx.fillRect(state.touchLane * CELL, 0, CELL, CANVAS_H);
}

// ─── Collision ────────────────────────────────────────────────

function checkCollisions() {
  const boatTop = state.boatScreenY - 10 * (CELL / 72);
  const boatBot = state.boatScreenY + 22 * (CELL / 72);

  for (const row of state.rows) {
    const rowTop = row.y;
    const rowBot = row.y + CELL;
    if (rowBot < boatTop || rowTop > boatBot) continue;

    const cell = row.cells[state.boatLane];
    if (!cell) continue;

    if (cell === 'rock' || cell === 'hippo' || cell === 'croc') {
      if (state.invincibleTimer <= 0) {
        state.stones -= 2;
        state.invincibleTimer = 90;
        spawnHitParticles();
        row.cells[state.boatLane] = null;
        if (state.stones <= 0) {
          state.stones = 0;
          state.gameOver = true;
          state.running = false;
          showOverlay('Shipwreck!',
            'You lost all your stones in the Nile.\nDistance: ' + state.distance + 'm\nPyramid: ' + state.pyramidStones + '/' + PYRAMID_GOAL,
            'Try Again');
        }
      }
      return;
    }

    if (cell === 'stone') {
      state.stones += 2;
      row.cells[state.boatLane] = null;
      spawnCollectParticles();
    }

    if (cell === 'delivery' && state.stones > 0) {
      const deliver = Math.min(state.stones, 5);
      state.stones -= deliver;
      state.pyramidStones += deliver;
      spawnDeliveryParticles();
      for (let c = 0; c < COLS; c++) row.cells[c] = null;

      if (state.pyramidStones >= PYRAMID_GOAL) {
        state.won = true;
        state.running = false;
        showOverlay('Pyramid Complete!',
          'You delivered ' + PYRAMID_GOAL + ' stones!\nThe Great Pyramid is built!\nDistance: ' + state.distance + 'm',
          'Play Again');
      }
    }
  }
}

// ─── Particles ────────────────────────────────────────────────

function spawnHitParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  const s = CELL / 72;
  for (let i = 0; i < 12; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 4 * s,
      vy: (Math.random() - 0.5) * 4 * s,
      size: (4 + Math.random() * 4) * s,
      life: 1,
      color: '#ff6644',
    });
  }
}

function spawnCollectParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  const s = CELL / 72;
  for (let i = 0; i < 8; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 3 * s,
      vy: -Math.random() * 3 * s,
      size: (3 + Math.random() * 3) * s,
      life: 1,
      color: '#66ccff',
    });
  }
}

function spawnDeliveryParticles() {
  const bx = state.boatLane * CELL + CELL / 2;
  const s = CELL / 72;
  for (let i = 0; i < 20; i++) {
    state.particles.push({
      x: bx, y: state.boatScreenY,
      vx: (Math.random() - 0.5) * 5 * s,
      vy: -Math.random() * 5 * s,
      size: (3 + Math.random() * 5) * s,
      life: 1,
      color: Math.random() > 0.5 ? '#c4943a' : '#e8d5a3',
    });
  }
}

// ─── Input: Keyboard ──────────────────────────────────────────

const keys = {};
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '].includes(e.key)) {
    e.preventDefault();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

let moveCD = 0;
function handleKeyboard() {
  moveCD = Math.max(0, moveCD - 1);
  if (moveCD === 0) {
    if (keys['ArrowLeft']  || keys['a'] || keys['A']) { moveBoat(-1); moveCD = 10; }
    if (keys['ArrowRight'] || keys['d'] || keys['D']) { moveBoat(1);  moveCD = 10; }
  }
  state.speed = (keys[' '] || keys['ArrowUp']) ? SCROLL_SPEED * BOOST_MULT : SCROLL_SPEED;
}

function moveBoat(dir) {
  if (!state.running) return;
  state.boatLane = Math.max(0, Math.min(COLS - 1, state.boatLane + dir));
}

// ─── Input: Touch ─────────────────────────────────────────────
// Tap a lane → boat moves there. Swipe left/right → shift one lane.
// Swipe up → boost while swiping.

let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let touchActive = false;
const SWIPE_THRESHOLD = 30; // px

function canvasTouchPos(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  // Map CSS display coords → canvas internal coords
  const scaleX = CANVAS_W / rect.width;
  const scaleY = CANVAS_H / rect.height;
  return {
    x: (touch.clientX - rect.left) * scaleX,
    y: (touch.clientY - rect.top) * scaleY,
  };
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (!state || !state.running) return;
  const pos = canvasTouchPos(e);
  touchStartX = pos.x;
  touchStartY = pos.y;
  touchStartTime = Date.now();
  touchActive = true;

  // Show lane highlight immediately
  state.touchLane = Math.floor(pos.x / CELL);
  state.touchLane = Math.max(0, Math.min(COLS - 1, state.touchLane));
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  const pos = canvasTouchPos(e);
  const dy = touchStartY - pos.y;

  // Swipe up → boost
  if (dy > SWIPE_THRESHOLD) {
    state.speed = SCROLL_SPEED * BOOST_MULT;
  } else {
    state.speed = SCROLL_SPEED;
  }

  // Update lane highlight
  state.touchLane = Math.floor(pos.x / CELL);
  state.touchLane = Math.max(0, Math.min(COLS - 1, state.touchLane));
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (!touchActive || !state || !state.running) return;
  touchActive = false;
  state.speed = SCROLL_SPEED;
  state.touchLane = null;

  const pos = canvasTouchPos(e);
  const dx = pos.x - touchStartX;
  const dy = touchStartY - pos.y;
  const elapsed = Date.now() - touchStartTime;

  // Swipe detection
  if (Math.abs(dx) > SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy)) {
    moveBoat(dx > 0 ? 1 : -1);
    return;
  }

  // Tap detection — move to the tapped lane
  if (elapsed < 300 && Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) {
    const tappedLane = Math.floor(pos.x / CELL);
    const clampedLane = Math.max(0, Math.min(COLS - 1, tappedLane));
    state.boatLane = clampedLane;
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  touchActive = false;
  if (state) {
    state.speed = SCROLL_SPEED;
    state.touchLane = null;
  }
});

// Prevent any residual scrolling
document.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

// ─── Overlay ──────────────────────────────────────────────────

const overlay    = document.getElementById('overlay');
const overlayT   = document.getElementById('overlay-title');
const overlayP   = document.getElementById('overlay-text');
const overlayBtn = document.getElementById('overlay-btn');

function showOverlay(title, text, btn) {
  overlayT.textContent = title;
  overlayP.textContent = text;
  overlayBtn.textContent = btn;
  overlay.classList.remove('hidden');
}

overlayBtn.addEventListener('click', () => {
  overlay.classList.add('hidden');
  resetGame();
  state.running = true;
});

// ─── HUD ──────────────────────────────────────────────────────

function updateHUD() {
  document.getElementById('hud-stones').textContent  = state.stones;
  document.getElementById('hud-pyramid').textContent = state.pyramidStones;
  document.getElementById('hud-dist').textContent    = state.distance;
}

// ─── Game Loop ────────────────────────────────────────────────

function update() {
  if (!state.running) return;

  state.frameCount++;
  handleKeyboard();

  for (const row of state.rows) {
    row.y += state.speed;
  }

  state.distAccum += state.speed;
  state.distance = Math.floor(state.distAccum / 3);

  while (state.rows.length > 0 && state.rows[state.rows.length - 1].y > CANVAS_H + CELL) {
    state.rows.pop();
  }

  while (state.rows.length === 0 || state.rows[0].y > -CELL) {
    spawnRow();
  }

  if (state.invincibleTimer > 0) {
    state.invincibleTimer--;
    state.flash += 0.3;
  }

  checkCollisions();
  updateHUD();
}

function draw() {
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawWater();
  drawLaneHighlight();
  drawRows();
  drawBoat();
  drawParticles();
  drawPyramidProgress();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// ─── Init ─────────────────────────────────────────────────────
resizeCanvas();
resetGame();
loop();

window.addEventListener('resize', () => {
  resizeCanvas();
});
</script>
</body>
</html>
